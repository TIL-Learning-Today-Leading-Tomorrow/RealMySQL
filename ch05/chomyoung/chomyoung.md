### 용어

- Lock(잠금): 서로 다른 작업에서 같은 자원을 동시에 필요로 할 때 자원 경쟁이 일어나는데, 이때 순서대로 사용되는 **`동시성을 보장`**하기 위한 기능
- 격리 수준: 격리 수준은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨

# **트랜잭션**

## 트랜잭션이란?

- 기본 정의: 논리적인 작업 단위. 이 작업 단위 자체가 100% 적용되거나 아무것도 적용되지않아야함을 보장해주는 것
- 목표: **데이터베이스의 일관성 유지**와 **안전한 데이터 처리**를 보장(**데이터 무결성 보장**)
- 하나의 작업 세트가 일부만 적용되지 않도록 함을 보장(**`작업의 완전성`** 보장)
    - 전부 commit 혹은 rollback

## 주의사항

- 트랜잭션은 꼭 필요한 최소의 코드에만 적용
    - 이유
        1. DB의 커넥션 수가 제한적이기에 자원을 효율적 관리 - **`설명1`**
        2. Lock의 유지 시간 최소화 ⇒ DB 성능 유지 - **`설명2`**
- 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제!
- 다른 성격의 작업은 트랜잭션 분리

# **MySQL 엔진의 잠금**

- 크게 MySQL 엔진 레벨과 스토리지 엔진 레벨로 나눌 수 있다.

### 1. 글로벌 락

- MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
- 정의: 모든 데이터베이스의 모든 테이블에 대해 쓰기 작업을 막는 Lock
- 대상: MySQL 서버 전체를 대상으로 Lock 설정
- 사용 예시: 주로 백업을 위한 목적이나 대규모 데이터를 조작하는 작업 중 데이터 무결성을 보장하기 위해 사용

### 2. 테이블 락

- 정의: 테이블 단위로 읽기 또는 쓰기 작업을 제한
- 대상: 개별 테이블 단위로 설정되는 Lock 설정
- 사용 예시: 여러 트랜잭션이 동시에 특정 테이블에 접근할 때 충돌을 방지하거나, 테이블에 대한 대량 작업을 수행할 때 사용

### 3. 네임드 락

- 정의: 지정한 문자열 이름에 따라 락을 설정하고 해제하여 **`여러 웹 서버가 동일한 리소스에 동시 접근하지 않도록 관리`**
    - 잠금을 설정한 문자열에 대해 동일한 락을 요청하는 다른 트랜잭션은 락이 해제될 때까지 대기
- 대상: 사용자가 지정한 임의의 문자열에 대해 Lock 설정
- 사용 예시:  1대의 서버에 여러 웹 서버가 접속하는 서비스에서 여러 웹 서버가 어떤 정보를 동기화 하는 경우
    - 네임드 락을 사용하면 하나의 서버만 해당 리소스에 접근할 수 있게 하여 경쟁상태를 방지할 수 있고, 타임아웃 기능 또한 제공하여 deadlock방지에 기여

### 4. 메타데이터 락

- 정의: 테이블의 스키마 변경, 인덱스 추가 등과 같은 작업 중 데이터 충돌을 방지하기 위해 사용
- 대상: 데이터베이스 객체(예: 테이블, 뷰 등)의 이름이나 구조를 변경할 때, 해당 객체에 설정되는 Lock
- 사용 예시: 테이블의 스키마 변경, 인덱스 추가 등과 같은 작업 중 데이터 충돌을 방지 ex) RENAME TABLE @@@

# **InnoDB 스토리지 엔진의 잠금**

<aside>
💡

레코드 기반의 잠금 기능을 제공 ⇒ 동시성 처리가 매우 뛰어나다.

**why? 잠금 범위를 최소화**하고, 트랜잭션 간 **병목 현상을 줄이며**, **데드락을 방지**하면서도 **동시 읽기 및 쓰기 작업을 병행**할 수 있기 때문에
**`설명3`**

</aside>

### 1. 레코드 락

- 정의: 레코드 자체가 아닌 인덱스의 레코드를 잠근다.
    - 인덱스 생성을 안했어도 **`자동 생성되는 클러스터 인덱스`**를 이용
- 대상: 특정 레코드(행)에 대해 Lock 설정 ⇒ 동시성이 높은 환경에서 충돌을 최소화하고 특정 행에 대한 안전한 접근을 보장
- 사용예시

    ```jsx
    -- 특정 레코드에 대해 잠금을 설정하는 트랜잭션
    START TRANSACTION;
    SELECT * FROM orders WHERE order_id = 123 FOR UPDATE;
    -- 해당 레코드에 대해 업데이트 작업 수행
    UPDATE orders SET status = 'processed' WHERE order_id = 123;
    COMMIT;
    
    // FOR UPDATE 구문을 사용하여 특정 레코드에 대해 락을 설정한 후 업데이트 작업을 수행
    // => 동시에 여러 트랜잭션이 같은 레코드를 변경하지 않도록 보호
    ```

- 설명: **`설명4`**

### 2. 갭 락

- 정의: 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어
- 대상: 레코드와 바로 인접한 레코드 사이의 간격만을 Lock 설정
- 사용예시: 갭 락 자체 보단 넥스트 키 락의 일부로 자주 사용된다.

### 3. 넥스트 키 락

- 정의: 바이너리 로그에 기록되는 쿼리가 Replica 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장
- 대상: 레코드 락과 갭락을 합친 Lock
    - 이는 트랜잭션이 실행되는 동안, 다른 트랜잭션이 해당 범위 내에서 레코드를 추가하거나 삭제하는 것을 방지
- 사용예시

    ```jsx
    SELECT * FROM employees WHERE id BETWEEN 100 AND 200 FOR UPDATE;
    // id가 100에서 200 사이인 레코드들뿐만 아니라, 그 사이의 갭도 잠금으로 보호
    // 이를 통해 다른 트랜잭션이 해당 범위 내에서 레코드 추가, 삭제 방지
    ```


### 4. 자동 증가 락

- 정의: AUTO_INCREMENT 칼럼이 사용된 테이블에 여러 레코드가INSERT 될 경우 각 레코드는 중복x, 순차적인 값을 가져야하는데 이를 보장하기 위해 사용되는 Lock 방식 ⇒ 중복되지 않는 ID 값을 안전하게 할당
- 대상: **AUTO_INCREMENT**를 사용하는 **컬럼**에 대한 Lock
- 사용예시

    ```jsx
    -- AUTO_INCREMENT가 설정된 테이블에 대해 여러 레코드 삽입
    INSERT INTO orders (product_id, quantity) VALUES (1, 100), (2, 50);
    
    // 여러 트랜잭션이 동시에 orders 테이블에 데이터를 삽입할 때, 
    // 각 레코드는 자동 증가 락을 통해 pk(고유한 주문번호) 부여
    // MySQL은 이 과정에서 자동으로 락을 설정하여 중복된 값이 할당되지 않도록 보장
    ```


# **MySQL의 격리 수준**

|  | Dirty Read | Non-Repeatable Read | Phantom Read |
| --- | --- | --- | --- |
| Read Uncommitted | 발생 | 발생 | 발생 |
| Read Committed | 없음 | 발생 | 발생 |
| Repeatable Read | 없음 | 없음 | 발생(InnoDB는 없음) |
| Serializable | 없음 | 없음 | 없음 |

## 격리 수준의 종류

### **1. READ UNCOMMITTED**

- 접근 범위: 각 트랜잭션에서의 변경 내용이 `COMMIT`, `ROLLBACK` 여부에 상관없이 다른 트랜잭션에서 조회할 수 있다.
- 문제
    - 아직 `COMMIT`되지 않은 내용이 조회되는 `DIRTY READ` 문제가 발생할 수 있다.

### **2. READ COMMITTED**

<img src="https://github.com/JeongHunHui/TIL/assets/108508730/14c00054-0a3f-4f90-81ca-8837184ce0cb">

- 접근 범위: `COMMIT`이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.
- 특징
    - 오라클 DBMS의 기본 격리 수준이자, 온라인 서비스에서 가장 많이 사용되는 격리 수준
    - 새로운 데이터가 들어오면 변경 전 데이터는 undo 로그에 저장하고, `COMMIT` 되기전에 다른 트랜잭션에서 조회하면 undo 로그에 있는 변경 전 데이터를 반환
- 문제
    - 하나의 트랜잭션 안에서 동일한 `SELECT` 쿼리로 데이터를 요청하면 항상 같은 결과를 가져오지 못하는 문제인 `NON-REPEATABLE READ` 문제가 발생할 수 있다.

### **3. REPEATABLE READ**

<img src="https://github.com/JeongHunHui/TIL/assets/108508730/585e69ad-4729-4e05-a66f-1cc7919bba55">

- 접근 범위: 트랜잭션 Id를 기준으로 자신 이후에 발생한 트랜잭션에서의 변경사항은 읽지 않는다.
    - 동일 트랜잭션 내에서는 동일한 결과를 보여줌을 보장(`NON-REPEATABLE READ` 문제 해결)
- 특징
    - InnoDB에서 기본으로 사용되는 격리 수준
- 문제
    - 원래 `REPEATABLE READ`는 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 `PHANTOM READ` 현상이 발생하지만 InnoDB에선 일부 특별한 쿼리(`FOR UPDATE` 등)를 제외하고는 발생하지 않는다.

### **4. SERIALIZABLE**
- 정의: 트랜잭션이 직렬화되어 실행된다. 즉, 트랜잭션들이 순차적으로 처리되며, 모든 동시성 문제가 완벽하게 방지
- 접근 범위: 하나의 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대 접근할 수 없다.
- 문제
    - 읽기 작업에도 읽기 잠금을 획득해야하므로 동시 처리 성능이 매우 떨어진다.
    - InnoDB는 갭 락과 넥스트 키 락 덕분에 `PHANTOM READ`가 발생하지 않기 때문에 사용할 이유 X

# 설명란

### 설명1

- DB 커넥션 풀은 애플리케이션과 DB 간의 연결을 관리하는 시스템으로서, DB와 연결된 커넥션을 일정 수만큼 미리 열어두고 app에서 요청 시 이를 할당
- 트랜잭션이 시작되면, 데이터베이스에 연결된 커넥션이 잠긴다. 이 커넥션은 트랜잭션이 완료될 때까지 다른 요청에 사용되지 못한다.
- 결국 새로운 요청이 들어왔을 때 사용할 수 있는 커넥션이 부족해지면서 **`병목 현상`**이 발생

### 설명2

- 트랜잭션이 진행되는 동안 데이터베이스는 Lock을 사용하여 데이터를 보호. 즉, 트랜잭션이 완료될 때까지 특정 테이블이나 row가 다른 트랜잭션에 의해 변경되지 않도록 잠금

  ⇒ 트랜잭션이 길어지면 다른 트랜잭션이 해당 데이터에 접근하지 못하게 되어 **데이터베이스 성능 저하**를 초래


### 동시성 문제 ~ 트랜잭션

- 동시성 문제: 여러 스레드나 프로세스가 **동시에 같은 자원**에 접근하거나 수정하려고 할 때 발생하는 문제
- 여러 트랜잭션이 동시에 같은 데이터에 접근할 때, 트랜잭션의 **격리 수준**에 따라 동시성 문제가 발생할 수 있다.
- 이를 방지하기위해 DB에서 Lock 혹은 트랜잭션 격리 수준을 설정하지만, 잘못 설정하면 데이터 일관성이 깨질 수 있다.
    - 더티 리드(Dirty Read), 반복 불가능한 읽기(Non-Repeatable Read), 팬텀 리드(Phantom Read)와 같은 동시성 문제 발생
        - **더티 리드(Dirty Read - READ UNCOMMITTED)**: 한 트랜잭션이 아직 커밋되지 않은 데이터를 읽는 경우.
        - **반복 불가능한 읽기(Non-repeatable Read - READ COMMITTED)**: 한 트랜잭션이 데이터를 읽은 후, 다른 트랜잭션이 그 데이터를 수정하면, 처음 읽은 값과 나중에 읽은 값이 달라지는 경우.
        - **팬텀 리드(Phantom Read - REPEATABLE READ)**: 한 트랜잭션이 데이터를 조회한 후, 다른 트랜잭션이 그 사이에 새로운 데이터를 삽입하여, 다시 조회할 때 데이터가 변경되는 경우.
    - 추가로, **SERIALIZABLE 격리수준**에서는 동시성 성능이 크게 저하될 수 있다.
    - Lock은 범위가 너무 넓으면 성능 저하, 제대로 해제하지않으면 DeadLock 발생 가능성(무한 대기)

### 동시성을 제어해야하는 이유

- **Race condition**
    - 두 개 이상의 스레드가 동시에 같은 데이터를 접근하여 값을 변경하고자 할 때, 데이터의 예상치 못한 변경이 발생할 수 있다.
- **DeadLock**
    - 두 개 이상의 스레드가 서로의 작업이 완료될 때까지 기다리면서 결국 아무도 완료되지 않는 문제가 발생할 수 있다.
- **Data corruption**
    - 두 개 이상의 스레드가 동시에 같은 데이터에 접근하여 값을 변경할 때, 예상치 못한 데이터의 변형이 발생할 수 있다.

### 설명3

### 레코드 기반의 잠금 기능이 동시성 처리에 좋은 이유

### 1. **잠금 범위가 작음 (작은 잠금 단위)**:

레코드 기반 잠금은 테이블 전체나 페이지 단위로 잠그는 대신, **특정 레코드**(즉, 데이터베이스의 하나의 행)에만 잠금을 설정합니다. 이렇게 하면 **다른 트랜잭션이 동일한 테이블의 다른 레코드에 자유롭게 접근할 수** 있으므로 **동시성이 높아집니다**. 예를 들어, 한 사용자가 특정 상품을 업데이트할 때, 다른 사용자는 동일 테이블의 다른 상품을 조회하거나 수정할 수 있습니다.

- **예시**:
    - 만약 테이블 잠금을 사용한다면, A 트랜잭션이 `users` 테이블에서 한 명의 사용자를 업데이트하는 동안, 다른 모든 트랜잭션은 해당 테이블에 접근할 수 없게 됩니다.
    - 반면, **레코드 기반 잠금**을 사용하면, A 트랜잭션이 `users` 테이블에서 특정 사용자를 업데이트하는 동안에도 다른 트랜잭션들은 해당 테이블의 다른 사용자 데이터를 자유롭게 조회하거나 수정할 수 있습니다.

### 2. **병목 현상 감소**:

레코드 단위로 잠금을 설정하면, **병목 현상**이 줄어듭니다. 테이블 전체를 잠그는 방식에서는 하나의 트랜잭션이 작업을 하는 동안 다른 트랜잭션들은 대기해야 하지만, 레코드 기반 잠금은 여러 트랜잭션이 동시에 다른 데이터를 처리할 수 있게 되어 **병목을 줄이고 동시성 처리량을 증가**시킵니다.

- **비교**: 테이블 잠금 방식은 대규모 트랜잭션이 하나 실행될 때, 작은 트랜잭션조차 대기해야 하지만, 레코드 기반 잠금에서는 큰 트랜잭션과 작은 트랜잭션이 동시에 처리될 수 있습니다.

### 3. **데드락 방지에 유리**:

레코드 기반 잠금은 잠금 범위를 최소화하기 때문에, **데드락(Deadlock)** 발생 가능성을 줄이는 데도 유리합니다. 테이블 수준의 잠금을 사용할 때는 서로 다른 트랜잭션이 여러 테이블에 동시에 접근하다가 교착 상태에 빠질 위험이 있지만, 레코드 단위 잠금은 잠금 범위가 좁아져 데드락 발생 가능성이 줄어듭니다.

### 4. **동시 읽기 처리 능력 향상**:

레코드 기반 잠금은 쓰기 작업 중에도 **동시 읽기**를 허용할 수 있습니다. 읽기 작업은 레코드에 대해 **공유 잠금**을 설정할 수 있으며, 쓰기 작업과는 충돌하지 않으므로, 읽기 트랜잭션이 동시에 여러 개 실행될 수 있습니다. 이는 성능을 크게 향상시킵니다.

### 설명4

- 인덱스와 Lock
    - 인덱스가 적절히 설정되어 있지 않으면 잠금의 범위가 커져서 동시성이 떨어진다.
    - 만약 아예 인덱스가 없다면 테이블을 Full Scan하며 UPDATE 작업을 하는데 이 과정에서 모든 레코드를 잠근다.

      ⇒ 잠금의 범위를 최소화할 수 있도록 인덱스 설계를 잘 해야한다

- **`자동 생성되는 클러스터 인덱스`**

  ### 1. **클러스터 인덱스란?**

    - **클러스터 인덱스**는 테이블의 **기본 키(primary key)**를 기준으로 **데이터 자체를 정렬하고 저장**하는 방식입니다. 즉, 테이블의 레코드들이 **기본 키 순서**에 따라 물리적으로 디스크에 저장됩니다.
    - 클러스터 인덱스는 **레코드 자체**를 포함하고 있으므로, 클러스터 인덱스의 검색은 곧 **레코드를 검색하는 것**과 동일합니다. 이를 통해 **빠른 검색**이 가능하게 됩니다.

  ### 2. **자동 생성되는 클러스터 인덱스**

  InnoDB는 다음과 같은 상황에서 **자동으로 클러스터 인덱스를 생성**합니다:

    - **기본 키가 없는 테이블**: 만약 테이블에 기본 키(primary key)가 명시적으로 정의되지 않은 경우, InnoDB는 자동으로 **첫 번째 고유(non-nullable) 인덱스**를 클러스터 인덱스로 사용합니다.
    - **고유 인덱스가 없는 테이블**: 만약 고유 인덱스조차 없는 경우, InnoDB는 내부적으로 숨겨진 6바이트 크기의 `row_id`라는 컬럼을 자동으로 생성하여 이를 클러스터 인덱스로 사용합니다.

  즉, 테이블에 기본 키나 고유 인덱스가 없는 경우에도 **InnoDB는 클러스터 인덱스를 통해 데이터를 효율적으로 관리**할 수 있습니다.

  ### 3. **레코드 락과 클러스터 인덱스**

    - **레코드 락**은 클러스터 인덱스에 의해 **잠금**이 설정됩니다. InnoDB에서는 레코드를 직접 잠그는 대신, **클러스터 인덱스에 기반한 인덱스 엔트리를 잠금**으로 처리합니다.
    - 테이블에 기본 키가 있으면 그 키를 기준으로 레코드를 잠금하며, 기본 키가 없더라도 자동 생성된 클러스터 인덱스를 사용해 레코드 잠금이 설정됩니다.

  ### 4. **왜 클러스터 인덱스가 중요한가?**

    - **성능 최적화**: 클러스터 인덱스는 레코드가 기본 키 순서대로 정렬되어 있으므로 **범위 조회, 검색, 정렬 작업**에서 매우 효율적입니다. 이를 통해 빠른 데이터 접근이 가능합니다.
    - **잠금 최소화**: 클러스터 인덱스를 사용한 레코드 락은 **테이블 전체가 아닌 개별 레코드에만 락을 설정**하므로, 다른 트랜잭션이 테이블의 다른 부분에 자유롭게 접근할 수 있게 됩니다. 이는 **동시성**을 높이고, 트랜잭션 간 **경쟁**을 줄이는 데 도움을 줍니다.

# 추가

- **Read Committed**는 **동시성**을 높이고 성능을 향상시킬 수 있지만, 데이터의 일관성이 약간 손상될 수 있습니다. 주로 **쓰기 작업**이 많고 **데이터 정합성**이 덜 중요한 시스템에서 사용합니다.
  - 성능과 동시성이 중요한 도메인에서 주로 사용되며, 최신 커밋된 데이터를 읽는 것이 중요하지만 완벽한 데이터 일관성을 보장할 필요가 없는 시스템에 적합합니다. 전자상거래 시스템의 장바구니나 소셜 미디어 뉴스 피드, 로그 처리 시스템에서 유용합니다.
- **Repeatable Read**는 트랜잭션 내에서 **데이터의 일관성**을 강하게 보장하지만, **동시성**이 떨어질 수 있습니다. 주로 **읽기 작업**이 빈번하거나 데이터의 **정확성이 중요한 시스템**에서 사용합니다.
  - 트랜잭션 내에서 일관된 데이터 읽기가 중요하며, 동일한 데이터를 반복해서 읽을 때 항상 같은 결과를 보장해야 하는 시스템에서 사용됩니다. 은행 거래 시스템, 재고 관리 시스템, 고객 주문 처리 시스템과 같은 데이터 정합성을 요구하는 도메인에서 적합합니다.

### 격리수준

- 각 격리 수준은 동시성 문제(Dirty Read, Non-Repeatable Read, Phantom Read)를 어느 정도 허용하느냐에 따라 성능과 데이터 일관성 사이의 균형을 다르게 맞춥니다.
- 사용예시
  - **Read Uncommitted** (커밋되지 않은 읽기 허용)
    - **로그 분석 시스템**: 로그 데이터가 연속적으로 수집되고 처리되는 상황에서는 데이터의 일관성이 엄격하게 필요하지 않으므로, 빠른 성능을 위해 **Read Uncommitted** 수준을 사용할 수 있습니다.
  - **Read Committed** (커밋된 읽기)
    - 빠른 조회와 데이터 일관성을 적절히 유지하는 **전자상거래 상품 조회** 등에 사용.
    - **온라인 쇼핑몰 조회**: 상품 재고를 조회할 때, 정확한 재고 정보가 필요하지만, 읽는 동안 재고가 변경될 수 있는 상황에서는 **Read Committed** 수준을 사용합니다.
  - **Repeatable Read** (반복 가능한 읽기)
    - **은행 거래**나 **금융 시스템**에서 중간 데이터 수정 방지.
  - **Serializable** (직렬화 가능한 수준)
    - **주식 거래**와 같은 고정밀 데이터 일관성이 필요한 시스템에서 사용.

### InnoDB는 왜 phantom read가 발생하지않는가
- **InnoDB**가 기본적으로 **Repeatable Read** 격리 수준에서 갭 락(Gap Lock)을 사용하여 이를 방지
- 갭락은 레코드 삭제를 방지하지않으나, 삭제된 레코드는 이미 트랜잭션 A에서 조회된 결과에 포함되어 있으며, 트랜잭션 도중에 그 레코드가 삭제되더라도 트랜잭션 A의 스냅샷에서 해당 레코드를 유지