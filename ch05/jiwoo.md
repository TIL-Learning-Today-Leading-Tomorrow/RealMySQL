# 글로벌 락
책에서 설명하는 글로벌 락의 예시로 mysqldump를 말한다. 이 때 무조건 글로벌 락이 선행되어야만 mysqldump가 실행가능한 것은 아니고 **일관된 백업**이 필요하기 때문이다.

그렇다면 변경이 발생하지 않을려면 어떻게 해야 할까? 크게 아래와 같다.

1. 글로벌 락을 걸어서 아무것도 변경을 못하게!
2. WAS나 APP 서비스를 내려서 DB에 어떤 세션도 접근하지 못하게! (이러면 락은 필요없다.)

결국 위에서 말하는 건 세션 인입을 차단함으로서 일관된 백업본을 만들 수 있다.
글로벌 락을 거는 것 또한 결국 서비스 차단과 동일한 행위이다.

하지만 아래와 같은 경우가 있다고 생각해보자.

3. 보통 서비스 대부분은 기본적으로 정책이 Daily 백업이다. 그런데 현재 DB는 24/365 기동되는 서비스이다. 그렇다면 매일 백업을 위해 특정 시간마다 서비스를 내려야 한다?

위와 같은 상황이라면 백업이 마치 불가능한 것처럼 들린다.
그러면 어쩔 수 없으니 글로벌 락을 걸지 말고 온라인 상태에서 백업을 하면 되지 않을까?

이제 다음으로 생기는 문제점은 다음과 같다.

- 매일 자정 백업을 진행하는 DB가 존재할 때 해당 DB 사이즈가 TB 단위라면 보통 10~20분만에 백업이 끝나는 경우는 없다. 백업이 총 3시간이 소요된다고 가정했을 때, 최초로 백업이 진행되었던 1 번째 테이블과 3시간 뒤의 마지막 1000번째 테이블의 백업 데이터는 결국 시점이 동일하지 않다.

이렇게 되면 해당 백업본은 사실상 사용 불가능한 백업본이 되버린다.   
(심지어 해당 시간대에 진행한 백업 작업으로 인하여 성능 저하도 발생했을 것이다.)

그러면 시점을 일관되게 유지하는 것은 불가능 한 것일까? 그렇지는 않고 mysqldump 에서 제공하는 **-single-transaction** 옵션을 사용한다. 이름에서 알 수 있듯이 이 일련의 백업 작업을 하나의 트랜잭션으로 처리하여 일관된 읽기를 가능하게 한다.  
(4장에서 설명된 MVCC가 사용된다고 생각하면 된다.)

Xtrabacup, Enterprise backup 등에서 백업 락을 통하여 온라인 상태의 백업을 가능하게 한다.
다만 위와 마찬가지로 그냥 데이터 파일을 카피하는 것 또한 당연히 일관된 백업본을 생성하지 못하므로 Xtrabackup의 경우 redo 로그를 통해 변경 사항을 추적하고 이를 백업 시작 시점으로 되돌리는 작업 등을 진행하여 일관된 백업을 만든다고 생각하면 된다.

# 넥스트 키 락

책에서 설명하는 넥스트 키 락의 필요성은 레플리카 서버와 소스 서버의 정합성을 위해서라고 말한다.
정합성이 왜 깨지게 되는지 명확한 설명이 없어서 이 부분을 추가하고자 한다.

기본적으로 Replication 구조에서 Master(소스 서버) -> Slave(레플리카 서버) 반영은 binlog 를 통해 이뤄지게 된다. 간단하게 binlog를 설명하자면 MySQL 서버의 모든 변경사항을 기록하는 로그라고 생각하면 된다. 앞서 4장에서 나왔던 redo log는 InnoDB에 종속되고 binlog는 스토리지 엔진 상관없이 존재한다.

어쨌든 binlog에 기록되는 변경 사항은 실제 데이터 변경이 발생하면 기록되는데, commit이 발생하면 기록된다와 동일한 의미이며 rollback은 반영되지 않는다. 

![image](https://github.com/user-attachments/assets/2af2777e-e054-4ea8-94da-11f7c3a3294c)

위와 같은 트랜잭션이 존재할 때 넥스트 키 락이 존재한다면 당연히 Session 2는 session 1 이 완료될 때 까지 대기하므로 1번의 update가 binlog 에 기록된 이후에 2번의 insert 가 binlog에 기록된다. 그리고 이 binlog의 기록이 그대로 slave에 반영되므로 두 DB간의 정합성이 뒤틀리진 않는다.

그러나 넥스트 키 락이 존재하지 않을 때를 가정해보자. 1번 세션이 update 를 실행하고 commit을 하지 않은 상태에서 2번 세션이 insert 를 먼저 commit을 할 수 있게 될 것이다. 이 때 binlog에 기록되는 변경사항은 2번 세션의 insert가 우선 기록될 것이고 slave에서는 insert Matt2 이후에 update 발생, 즉 Matt2 까지 Dummy 로 변경될 것이다.

물론 Master 서버에서는 1번 세션의 commit이 뒤늦게 되었더라도 해당 시점의 데이터만 변경할 것이므로 2번 세션의 Matt2 insert 가 먼저 commit 되었더라도 해당 row 까지 업데이트 하진 않았을 것이다.

결론적으로 Master와 Slave의 정합성이 깨지게 되는 것이다. 사실 넥스트 키 락이 비활성화 될 일이 없고 isolation 레벨을 read commited 로 변경하더라도 binlog 포맷이 statement 일 때 DML 작업이 불가하다 보니 위에서 고려하는 정합성이 깨지는 문제는 아예 발생 안할 거 같기도 하다.

참고 링크 : 
https://medium.com/daangn/mysql-gap-lock-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B0-7f47ea3f68bc


# 참고

### 논리 백업  
책에서 설명한 mysqldump는 논리 백업이다. DB의 파일을 복사하는 것이 아닌 현재 오브젝트의 상태를 쿼리로 저장하는 것이다. 이 때문에 실제 결과물은 .sql 파일이다. 해당 백업의 경우 사용이 간편하긴 하나 DB 온라인 상태에서만 가능하며 DB 사이즈가 커진다면 소요 시간이 너무 길어지기 때문에 Daily 백업에 잘 사용되지 않는다.  
(백업 시간이 너무 길어져서 하루 이상의 백업이 소요된다면 결국 이는 더 이상 Daily 백업이 아니게 된다. 추가로 백업 자체가 DB 리소스 부하를 발생하므로 하루종일 돌면서 DB 성능 저하도 발생하게 된다.)

### 물리 백업
추가로 설명된 Xtrabackup, Enterprise backup은 물리 백업이다. 물리적으로 존재하는 데이터 파일, Undo 파일, redo 파일 등을 지정한 디렉토리 위치에 그대로 카피하는 것이다. 즉 현재 DB에 존재하는 파일과 1대1로 동일한 백업본이 생기는 것이다. 논리 백업보다 시간이 더 빠르고 **시점 복구**가 가능하다는 매우 큰 장점이 존재한다.


### Replica 서버?
락 설명 중 소스 서버, 레플리카 서버 같은 용어가 나오는데 이는 DB 이중화 방식 중 하나인 Replication 구조를 말하는 것이다.

![image](https://github.com/user-attachments/assets/ff1c928f-d357-4a18-a72f-1db0f04fb8bb)

간단하게 스페어 타이어를 가지고 다니는 것과 동일하다. DML 작업은 보통 Master에서 진행하고 Slave 쪽은 read_only 옵션을 설정하여 읽기 작업만 가능하게 구성한다. 이를 통해 Master DB 장애 시 Slave의 Master 승격을 통해(Failover) 서비스 중단을 최소화할 수 있고 세션을 Slave 쪽으로 분배할 수 있으므로 성능 향상도 꾀할 수 있다.

참고 링크 : https://server-talk.tistory.com/240